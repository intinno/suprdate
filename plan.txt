=== DateTraversal

  %w{Year Day Month Week}.each do |type| 
    eval "def #{type}(*args) DEFAULT_BUILDER.#{type.downcase}(*args) end"
  end
  
  def d(*args) DEFAULT_BUILDER.d(*args) end
  def today() end
  def every(x, enum, &block)
    out = if block
      enum
    else
      block = lambda { |value| out << value } 
      []
    end
    enum.each_with_index do |value, key|
      block.call(value) if key % x == 0
    end
    out
  end
    
  === INF
  
    <=> # -1
    succ # dummy
    
  === WeekDefinition
  
    year_from_week(Week) # Year
    weeks_of_year(Year) # [Week]
    week_start_offset # Integer
    def use!
      ::DEFAULT_BUILDER.week_definition = self
    end
    
    # singleton instances
    
      ISO8601_WEEK
      USA_WEEK
      UK_WEEK
    
  === Builder
  
    week_definition
    week_definition=
    year
    day
    month
    week
    d
    
  === Year

    #initialize(Integer = Time.now.year)
    #month(Integer) # Month
    #months # [Month]
    #days # [Day]
    #leap? # Boolean
    #inspect # String
    #attr_accessor :month_class
    #              :week_class 
    #              :week_definition
    
    week(Integer) # Week
    weeks # [Week]
    <=>(Day || Week || Month || Year) # Integer
  
  === Month

    #initialize(Year, Integer || Symbol || String)
    #to_i # January is 1
    #num_days # Integer
    #days # [Days]
    #day(Integer) # Day
    #attr_accessor :day_class
    #year # Year
    #to_sym # :jan
    #succ # Month
    #+(Integer) # Month
    #-(Integer) # Month
    #inspect # String
    #since(Month) # Integer
    #until(Month) # Integer
  
    <=>(Day || Week || Month || Year) # Integer
    
  === Week

    attr_accessor :day_class
    initialize(Year, Integer)
    days # [Day]
    day(Integer || Symbol || String) # Day
    month # always raises
    year # Year
    num_years_spanned # 1 || 2
    num_months_spanned # 1 || 2
    of_year # Integer
    succ # Week
    prev # Week
    +(Integer) # Week
    -(Integer) # Week
    since(Week) # Integer
    until(Week) # Integer
    <=>(Day || Week || Month || Year) # Integer
    inspect # String
  
  === Day

    #initialize(Month, Integer)
    #year # Year
    #month # Month
    #time # Time
    #date # Date
    #days # [self]
    #date_time # DateTime
    #of_month # Integer of 1..31
    #of_week_as_s # "Monday"
    #of_week_as_sym # :mon
    #of_week_as_i # 1
    #of_year # Integer
    #leap? # is February 29th? Boolean
    #succ # Day
    #+(Integer) # Day
    #-(Integer) # Day    
    #since(Day) # Integer
    #till(Day) # Integer    
    #<=>(Day || Week || Month || Year) # Integer
    #inspect # String
    
    week # Week
    
require 'date_traversal'
include DateTraversal
ISO8601_WEEK.use!

months = []
(Year 2000 .. Year 2010).each { |year| months << year.months[0..2] }
months.flatten!

days = []

=== How the API has Progressed

  === Before:
    every 1, :months, :on => [1], :from => [2008, 11], :to => [2009, 3] { |date| }
  === After:
    (Month(Year(2008), 11)..Month(Year(2009), 3)).map { |m| m.day(1).date }.each { |date| }
    
  === Before:
    every 1 :months, :fifth => [:tue, :fri], :third => [:mon], :from => [2008] { |date| }
  === After
    (Day(Month(Year(2008), 1), 1) .. INF).each do |day|
      if day.weekday_of_month?(:fifth => [:fri, :tue], :third => :mon)
        day.date
      end
    end

  === Before:
    every 2, :weeks, :from => :today, :on => [:mon, :tue, :wed] { |date| }
  === After:
    every(2, today.week .. Inf) do |w| 
      w.days.select { |d| [:mon, :tue, :wed].include? d.of_week_as_sym }.each do |d| 
        d.date
      end
    end


=== Specification

weekday_of_month?(Hash) # Boolean
  # {1 => :mon} # first monday
  # {1 => [:mon]} # first monday
  # {1 => [:mon, :tue]} # first tuesday
  
spec = EventSpec.new
spec.repeats(:monthly, :from => Year(2009), :to => Year(2010))
spec.when_day_of_month(:third => [:fri, :sat], :fifth => :mon)
spec.when_day_of_month([3, 7, 8])
spec.specified_days do |day|

end

=== Stuff To Do

  - Think about how the decending factories thing is working. I can't test for it any longer
  - Change "x_class" to "x_factory"
  - API documentation
  - Odd extra few comments for understandability
  - Manual
  - Packaging
  - GitHub / RubyForge / Google Code / Gem
